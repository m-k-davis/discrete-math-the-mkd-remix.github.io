= Proofs: Mathematical Induction

#*CAUTION* - CHAPTER UNDER CONSTRUCTION!#

_This chapter was last updated on August 27, 2024._

////
PROOFS: MATHEMATICAL INDUCTION (MKD) 
	based on SEQUENCES, RECURSIVE DEFINITIONS, AND INDUCTION (GGC11)
	ACM CCECC Mathematical induction	
    COMP 152 Proof Techniques and DS3.
		examples of mathematical induction
		strong induction
        Mathematical induction
        Strong induction
        Well orderings
	ACTIVITY: Induction
	MKD: Do sum of odd integers as "easy" first example
	MKD: Prove Euclidean Algorithm and some others as validation
	MKD: Find a "structural induction" example if possible, too
	MKD: Fundamental Theorem of Arithmetic using strong induction
	2013 changes/additions        
		[Core-Tier1]
			Induction over natural numbers
			Structural induction
			Weak and strong induction (i.e., First and Second Principle of Induction)
			Recursive mathematical definitions
	[Core-Tier2]
			Well orderings
			
			
AUG 2024 update on topics
Induction over natural numbers
Mathematical induction
examples of mathematical induction
Structural induction
Weak and strong induction (i.e., First and Second Principle of Induction)
Strong induction
Well orderings (MKD: so this chapter comes after Relations)

Also maybe Principle of Inclusion and Exclusion (general case)
		do 3-sets in Set Theory
		do more general PIE here in Induction. Use bitstrings? 

Prereqisites: Do sequences, primes and factors, fibonacci BEFORE this

Examples to do: Mathematical Induction
	sum of odd positive integers, 
	sum of powers of 2, maybe 
	3 divides 2^{2n}-1, 
	sum of odd indexed Fibonacci numbers
	see old examples on slides 19-26)
	Verification of Euclidean Algorithm for GCD
	Strong Induction - Fundamental Theorem of Arithmetic		
	Strong Induction - see only example on slide 28 (recurrence relation)
		
Emphasize that 
	Recursion is about DEFINITION and computation
	Induction is about VALIDATION and proof
////

//MKD - note that everything ater the "lego block" example may need to be rewritten.

//MKD add discussion of Well-Ordering Principle axion (after the example?)
//== What is Mathematical Induction?

//MKD other stuff to add
// "Small" integer is a relative term - consider the sequence of numbers 2, 2^2=4, 2^4=16, 2^16=65536, 2^65536 which is approximately 2 × 10^19728, and 2^(2^65536) which has about 6.031226062630295×10^19727 decimal digits, ... would you like to see other "small" integers?
// Induction is like verifying that a loop produces the expected output, for example 
// n = input("Type a positive whole number.")
// s = 0 
// for i = 1 to n
//		s = s + 2i-1
// print("The sum of the first",n,"odd positive integers is", str(s)+".")
// #Is s always a perfect square? How can you know for a "small" integer like 2^65536?


// MKD: The commonly-used "infinite ladder" analogy is misleading. 
// This analogy may appear in the original book. 
// The goal of mathematical induction is to produce a proof of FINITE LENGTH 
// that shows that a ladder of any specified natural number height $n$ 
// can be built, and that there is no upper bound on $n$. 
// That is, a FINITE ladder of any possible height can be built, but not an infinite ladder. 
// MKD thinks that a better analogy is code that uses a loop. The loop can be executed any FINITE number of times, but cannot truly be an "infinite loop" that never breaks.

_Mathematical induction_ is a proof technique that is used to prove 
infinitely many propositions using only two steps, where each of the
steps is of finite length (in terms of time, symbols, words, phonemes, etc.). 
Recall that a proof consists of finitely many propositions, 
where each proposition has a finite length.





== Why Is Mathematical Induction Needed?

//We often come across a connection between two different patterns tath may not seem to be connected at first, but for which there is a 

//MKD code for motivating example
//https://pythontutor.com/render.html#code=n%20%3D%20int%28input%28%22Type%20a%20positive%20integer%20into%20the%20box%3A%22%29%29%0A%23%20code%20throws%20ValueError%20if%20input%20is%20not%20an%20integer%0A%23%20initialize%20variables%0As%20%3D%200%0Ai%20%3D%201%0A%23%20loop%20n%20times%0Awhile%20i%20%3C%3D%20n%3A%0A%20%20%20%20s%20%3D%20s%20%2B%20%282*i-1%29%0A%20%20%20%20i%20%2B%3D%201%0Aprint%28s%29&cumulative=false&curInstr=17&heapPrimitives=false&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%224%22%5D&textReferences=false

//https://pythontutor.com/render.html#code=numOdds%20%3D%204%0Asum%20%3D%200%0Ai%20%3D%201%0A%23%20loop%20n%20times%0Awhile%20i%20%3C%3D%20numOdds%3A%0A%20%20%20%20sum%20%3D%20sum%20%2B%20%282*i-1%29%0A%20%20%20%20i%20%2B%3D%201%0Aprint%28sum%29&cumulative=false&curInstr=17&heapPrimitives=false&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false

:pt_code_height: 350
:pt_rawinput: false
:pt_code:  sum%20%3D%200%0Ai%20%3D%201%0A%23%20loop%20n%20times%0An%20%3D%204%0Awhile%20i%20%3C%3D%20n%3A%0A%20%20%20%20sum%20%3D%20sum%20%2B%20%282*i-1%29%0A%20%20%20%20i%20%2B%3D%201%0Aprint%28sum%29

****
.Example {counter:MKDinductionexample}
--
--
The code below prints the sum of the first $n$ odd positive numbers for the assigned value of $n$. 
//What does 
//How do we know that the code does what it claims to do?
How can we verify that the code computes this correctly for _every_ possible value of $n$?


Try to predict the variable names, values, and data types at different steps in the execution. Use the _Next_ button to check your answers.
include::python_tutor.adoc[]
****



//The next example illustrates why mathematical induction is needed.
In the preceding example, we could imagine running the code for each positive integer value of $n$, but this would require an infinite number of runs and/or using a loop that must execute an infinite number of times. 
If we could find a pattern linking the computed result for one integer to the result computed for the next largest integer, we could try to use that to justify that the code will always work without needing to run it for every value of $n$.  The following example illustrates how we can do this. 

// MKD start of square example

// MKD Remember to add in Python loop code as an analogy for induction
//	initialization is the basis step
//	the loop represents multiple applications of the induction step
//	the loop executes only a finite number of times, but as many times as needed, and we could store the results if we need to prove the predicate for a larger value.

****
.Example {counter:MKDinductionexample} - Why Use Mathematical Induction?


[.float-group]
--
// MKD needs to make attribution visible in HTML
[.left.text-left]
//image::imagesMKD/Square_number_16_as_sum_of_gnomons.svg[GGC,250,250]
image::imagesMKD/Square_number_16_as_sum_of_gnomons.svg[GGC]
// Page URL: https://commons.wikimedia.org/wiki/File:Square_number_16_as_sum_of_gnomons.svg
// File URL: https://upload.wikimedia.org/wikipedia/commons/0/06/Square_number_16_as_sum_of_gnomons.svg
// Attribution: Stefan Friedrich Birkner, CC BY-SA 3.0, via Wikimedia Commons
// Stefan Friedrich Birkner, CC BY-SA 3.0 <https://creativecommons.org/licenses/by-sa/3.0>, via Wikimedia Commons
// Description: English: 16 balls arranged as sum of gnomons of squares.
--

The preceding image shows $16$ colored "balls" arranged as a square. 

Consider the predicate $P(n)$: "The sum of the first $n$ positive odd integers is equal to $n^{2}$." 
//Recall that a predicate is a function that associates to each input a proposition.
Recall that a predicate is a function that maps each input in 
the predicate's domain to a proposition.

// MKD: FIX THIS PYTHONTUTOR CODE - IT IS PULLING IN AN EARLIER EXAMPLE
:pt_code_height: 300
:pt_rawinput: false
:pt_code: def%20P%28n%29%3A%0A%20%20%20%20return%20%22The%20sum%20of%20the%20first%20%22%20%2B%20str%28n%29%20%2B%20%22%20positive%20odd%20integers%20is%20equal%20to%20%22%20%2B%20str%28n*n%29%20%2B%20%22.%22%0An%20%3D%204%0Aprint%28P%28n%29%29%0A


In the following code snippet, function $P$ implements the predicate used in this example. 
Recall that the predicate's output is the _proposition_ itself, but the output does not indicate whether that proposition is true of false.

include::python_tutor.adoc[]


Think about how the image can be used to prove that each of the following four propositions is true.

* $P(1)$: "The sum of the first $1$ positive odd integers is equal to $1^{2}$." (I know, this is not proper US English!)

* $P(2)$: "The sum of the first $2$ positive odd integers is equal to $2^{2}$."

* $P(3)$: "The sum of the first $3$ positive odd integers is equal to $3^{2}$."

* $P(4)$: "The sum of the first $4$ positive odd integers is equal to $4^{2}$."

How can you change the image so that it could be used to prove that $P(5)$ is true, too ? 
How would you need to change the image to prove that $P(n)$ is true for _every_ possible choice for the positive integer $n$ ? Note that stating a _conjecture_ such as "It seems like it must be true for any positive integer $n$" is *not* a valid mathematical proof !

To prove that $P(n)$ is true for _every_ positive integer $n$ using images, 
we need either an infinite number of images (one image for each positive 
integer $n$) or one image of an infinitely large "square". 
Notice that neither of these options gives a proof of finite length.

The following code could be used to prove $P(n)$ for many more values of $n$, but we would eventually run into constraints based on time and computing resources.

// MKD: FIX THIS PYTHONTUTOR CODE - IT IS PULLING IN AN EARLIER EXAMPLE
:pt_code_height: 400
:pt_rawinput: false
//:pt_code: n%20%3D%204%0Ai%20%3D%201%0AsumInt%20%3D%200%0AsumStr%20%3D%20%22%22%0Awhile%20%28i%20%3C%3D%20n%29%3A%0A%20%20%20%20oddInt%20%3D%20%282*i-1%29%0A%20%20%20%20sumInt%20%2B%3D%20oddInt%0A%20%20%20%20sumStr%20%2B%3D%20str%28oddInt%29%0A%20%20%20%20i%20%2B%3D%201%0A%20%20%20%20if%20%28i%20%3C%3D%20n%29%3A%0A%20%20%20%20%20%20%20%20sumStr%20%2B%3D%20%22%20%2B%20%22%0Aprint%20%28sumStr,%22%3D%22,%20sumInt%29%0A
:pt_code: def%20P%28n%29%3A%0A%20%20%20%20return%20%22The%20sum%20of%20the%20first%20%22%20%2B%20str%28n%29%20%2B%20%22%20positive%20odd%20integers%20is%20equal%20to%20%22%20%2B%20str%28n*n%29%20%2B%20%22.%22%0An%20%3D%204%0Ai%20%3D%201%0AsumInt%20%3D%200%0AsumStr%20%3D%20%22%22%0Awhile%20%28i%20%3C%3D%20n%29%3A%0A%20%20%20%20oddInt%20%3D%20%282*i-1%29%0A%20%20%20%20sumInt%20%2B%3D%20oddInt%0A%20%20%20%20sumStr%20%2B%3D%20str%28oddInt%29%0A%20%20%20%20i%20%2B%3D%201%0A%20%20%20%20if%20%28i%20%3C%3D%20n%29%3A%0A%20%20%20%20%20%20%20%20sumStr%20%2B%3D%20%22%20%2B%20%22%0Aprint%20%28sumStr,%22%3D%22,%20sumInt%29%0AnSquared%20%3D%20n*n%0Aif%20%28sumInt%20%3D%3D%20nSquared%29%3A%0A%20%20%20%20print%28P%28n%29%29%0A


Use the _Next_ button to step through the program below.

include::python_tutor.adoc[]

To prove that $P(n)$ is true for _every_ positive integer $n$ using the code, 
we need one output from the function for each positive integer $n$, that is, 
we would need an infinitely long proof, which is infeasible.
//However, we would require an infinite number of images or an infinite number of outputs from the 
//function to prove that $P(n)$ is true for _every_ positive integer $n$.

For example, if you needed to convince someone that the proposition 
$P(1,\!000,\!000)$ must be true by drawing the complete image for that 
value of $n$, you would draw a square with $1,\!000,\!000$ rows 
each containing $1,\!000,\!000$ balls, for a total of 
$1,\!000,\!000,\!000,\!000$ 
balls. And then what if that person asked you to prove that 
$P(1,\!000,\!000,\!000,\!000$)$ is true ?!?!? Even the code would likely 
fail to prove this unless you have a lot of time and computing resources 
available.

This is why mathematical induction is used: The induction step justifies that we can (in principle) complete as large a finite number of these proofs as 
we need to by assuming we already have drawn the $k \times k$ square of balls to prove that $P(k)$ is true 
then we can use the pattern suggested in the image to enlarge the square to a $(k+1) \times (k+1)$ square of balls that proves $P(k+1)$ must be true. Or, in terms of the Python code, we already can prove that the output for input int $k$ is a square, and can show that this implies that the output for input int $k+1$ is _also_ a square.
 
That is, we _could_ write down as large a finite number of proofs as we need to prove $P(n)$ for a specifically chosen value of $n$... but since there is no bound on this chosen value of $n$, we in fact have proven the predicate $P(n)$ for *all* positive values of $n$.

NOTE: Mathematical induction does NOT state that we can write a 
_single_ proof of $\forall n P(n)$ but instead 
let's us justify that we can in principle write down a proof of $P(n)$ for 
every possible value of $n$. To clarify, if we first choose a 
_specific value for the integer_ $n$, then we can  
write a proof of $P(0)$ (and stop if $n = 0$), and then 
write a proof of $P(1)$ that builds on the proof of $P(0)$ (and stop if $n = 1$), and then 
write a proof of $P(2)$ that builds on the proof of $P(1)$ (and stop if $n = 2$), and so on, 
until we have written a proof of $P(n)$ that builds on the proof of $P(n-1)$.  

We will prove that the predicate $P(n)$ is true for all positive integers $n$ - in this case it does not make sense to have ``the sum of the first $0$ positive integers'', so the basis step will use $n=1$, which corresponds to the single red ball in the image, instead of $n=0$, which would correspond to $0$ balls.


.Solution
Basis Step: In this case, the basis corresponds to $n=1$.
// Is $1 = 1^{2}$? (Please answer "Yes!")
// Since $1 = 1^{2}$, the predicate $P(n)$ is true for $n=1$.
$P(1)$ is the proposition ``The sum of the first $1$ positive odd integers is equal to $1^{2}$.''

$P(1)$ is a true proposition since $1 = 1^{2}$ (Note that the only term in the sum on the left-hand side of the equation is $1$). 
The predicate $P(n)$ is true for $n=1$.

It may seem a bit strange to use "the sum of the first $1$ odd integers", so we can do an additional basis step for $n=2$. THIS IS NOT NECESSARY, but may aid in seeing the pattern. $P(2)$ is the proposition ``The sum of the first $2$ positive odd integers is equal to $2^{2}$.''

Induction Step:
We will _assume_ that the proposition $P(k)$ is true and prove that $P(k+1)$ must also be true. In this context, the proposition $P(k)$ is called the *induction hypothesis* (and $P(k+1)$ could probably be called the induction conclusion, but I've never seen anyone use that name).

Now, how do we _generalize_ the pattern seen in the image of the $16$ "balls" ?
Well, suppose we have a $k \times k$ square arrangement of such balls... how do we add in the new gnomon of balls to increaese the square to $(k+1) \times (k+{1)}$ ? 
We can add a new row of $k$ balls at the top, and a new column of $k$ balls to the right, and then $1$ additional ball at the upper right. 
So, as an algebraic equation, we'd like to show that 
$k^{2} + k + k + 1 = (k+1)^{2}$.

//MKD: POINT OUT THAT $2k-1$ REPRESENTS THE $k\text{th}$ POSITIVE ODD INTEGER - MAYPE INTRODUCE A TABLE AND HAVE STUDENTS SHOW THAT THE LINEAR EXPRESSION $2k-1$ CAN BE FOUND FROM THE TABLE.

That is, assume that $P(k)$ is true, where $k$ is some unspecified positive integer (again, this is called the *inductive hypothesis*). Based on the formula for the $k\text{th}$ odd positive integer, we can rewrite $P(k)$ as the equation \[1+3+...+(2k-1) = \sum\limits_{i=1}^{k}(2i-1) = k^{2}.\]

Now we _prove that this implies $P(k+1)$ is true._
That is show 
\[\sum\limits_{i=1}^{k+1}(2i-1) = \left(\sum\limits_{i=1}^{k}(2i-1)\right) + (2(k+1)-1) =  k^{2} +  (2(k+1)-1)\] 
where we have substituted $k^{2}$
for the sum $\sum\limits_{i=1}^{k}(2i-1)$ based on the inductive hypothesis. 

Now we simplify this using algebra and show that it is the same as the right hand side.
\[\sum\limits_{i=1}^{k+1}(2i-1) = k^{2} + (2(k+1)-1) = k^{2} + 2k + 2 - 1 
= k^{2} + 2k + 1 = (k+1)^2.\]

We have proven that the equation $1+3+...+(2k-1) = \sum\limits_{i=1}^{k}(2i-1) = k^{2}$ implies the equation 
$1+3+...+(2k-1) + (2k+1) = \sum\limits_{i=1}^{k+1}(2i-1) = (k+1)^{2}$, that is, $P(k) \rightarrow P(k+1)$.

Conclusion of the proof:
We have proven both the basis step and the induction step, therefore, 
// by the principle of mathematical induction, 
$1+3+...+(2n-1) = \sum\limits_{i=1}^{n}(2i-1) = n^{2}$ for all positive integers $n$.
****
//MKD end of square example



We can now formalize what we did in the example above. 
Suppose that we have a predicate $P(n)$ that is defined for all $n \in \mathbb{N}$, that is, $P$ is a function that maps each natural number to a corresponding proposition, and that we need to prove that each of the infinitely many propositions $P(0),\ P(1),\ P(2),\ldots$ is true. Since there are infinitely many values of $n$, this would appear to require infinitely many proofs, which is not feasible. BUT... let's suppose that we can prove the following two things about the predicate $P(n)$:

* ``The proposition $P(0)$ is true.'' This is called the *basis step*.

* ``The implication $P(k) \implies P(k+1)$ is true for every possible choice for the natural number $k$.'' This is called the *induction step*.

The proofs of each of the two bulleted statements will be of finite length, but will allow us to conclude (by using the Well-Ordering Principle) that $P(n)$ is true for *every* natural number $n \geq 0$. That is, we can conclude that $\forall n P(n)$ is a true propostion.

NOTE: In some cases, that basis step will involve a positive integer $c$ instead of $0$. As long as both the basis step and induction step have been proven, we can conclude that that $P(n)$ is true for *every* natural number $n \geq c$.

[.float-group]
--
// MKD needs to make attribution visible in html
[.left.text-left]
image::imagesMKD/CLIP-IS-A-BRICK_2x3.svg[GGC,250,250]
// Illustration of color plastic block.
//	found at https://publicdomainvectors.org/en/free-clipart/2x3-kids-brick-element-red-vector-image/31414.html
//	Source: http://openclipart.org/detail/224273/clip-is-a-brick-2x3
//	License: Public domain 
//	https://web.archive.org/web/20150923003735/https://openclipart.org/detail/224273/clip-is-a-brick-2x3
//	By: Vanja (https://web.archive.org/web/20150923003735/https://openclipart.org/user-detail/Vanja)
--
As an analogy, imagine we are building a tower using interlocking toy blocks. How tall can the tower be? 
// The basis step involves placing a foundational block on the ground, 
The basis step involves placing a foundation on the ground (either a flat surface for $n = 0$, or a first block for $n = 1$), 
and the induction step justifies that if we have built a tower that has height $k$ then we can build a tower of height $k+1$ by placing one more block on the tower. Note that we never build an infinitely tall tower, but we show that we can build a tower that is of any finite height $n$ (as long as we have $n$ or more blocks and ignore issues arising from real-world physics!).





// MKD: Not sure where this code goes - window was open after several days of fighting the flu :(
//https://pythontutor.com/render.html#code=%23%20set%20value%20of%20n%0An%20%3D%204%0A%23%20loop%20n%20times%0Ai%20%3D%201%0Asum%20%3D%200%0Awhile%20i%20%3C%3D%20n%3A%0A%20%20%20%20nextOdd%20%3D%20%282*i-1%29%0A%20%20%20%20sum%20%3D%20sum%20%2B%20nextOdd%0A%20%20%20%20print%28nextOdd,%22%2B%20%22,%20end%3D%22%22%29%0A%20%20%20%20i%20%2B%3D%201%0Aprint%28%22%3D%22,sum%29&cumulative=false&heapPrimitives=false&mode=edit&origin=opt-frontend.js&py=311&rawInputLstJSON=%5B%5D&textReferences=false


//MORE TO COME!
////
// MKD start of skipped example
//

Here is another example


****
.Example {counter:MKDinductionexample} - Proof by Induction
$$\sum\limits_{i=1}^{n}i=1+2+...+n=\frac{n\left(n+1\right)}{2}$$by 

This is a sequence of statements in terms of $n$ telling me that the sum of the first $n$ integers is going be equal to some formula that depends on the final number $n$ that you want to add.

.Solution
Basis Step:
When $n=1$, there is only 1 term to add.  _Does $1 \overset{?}{=}\frac{1\ \left(1+1\right)}{2}$?_

Since $1=\frac{2}{2}$, this formula is valid when $n=1$.

It also checks out when $n=2$. $1+2=\frac{2\ \left(2+1\right)}{2}$

We may continue with $n=3, n=4, ….$, etc., and notice that we want to prove an infinite collection of propositions. Specifically, we want to establish this claim for every positive integer.

Inductive Step:
Assume the statement is true for $P(m)$.

That is $\sum\limits_{i=1}^{m}i=1+2+...+m=\frac{m\left(m+1\right)}{2}$ (called the inductive hypothesis).

_Prove that this implies $P(m+1)$ is true._
That is show $\sum\limits_{i=1}^{m+1}i=1+2+...+m+(m+1)=\frac{(m+1)\left(m+1+1\right)}{2}=\frac{(m+1)\left(m+2\right)}{2}$

Begin with the left side $1+2+...+m+(m+1)$

We can rewrite this as $\frac{m\left(m+1\right)}{2}+(m+1)$ using the induction hypothesis.

Now we simplify this using algebra and show that it is the same as the right hand side.

Factoring out $(m+1)$ gives,

$\left(m+1\right)\left(\frac{m}{2}+1\right)=\left(m+1\right)\left(\frac{m}{2}+\frac{2}{2}\right)=\left(m+1\right)\left(\frac{m+2}{2}\right)=\frac{\left(m+1\right)\left(m+2\right)}{2}$

Which is the same as the right-hand side!

So $1+2+...+m+(m+1)=\frac{\left(m+1\right)\left(m+2\right)}{2}$, which means we have shown $P(m+1)$ follows from $P(m)$.

So, by induction, $\sum\limits_{i=1}^{n}i=1+2+...+n=\frac{n\left(n+1\right)}{2}$ for all positive integers $n$.
****
////
// MKD end of skipped example
//



////
// MKD - moved divisibility and gcd content to induction chapter


== Divisibility

Let $a$ be a nonzero integer and let $b$ be an integer. We say that *$a$ divides $b$* if and only if there is an integer $c$ such that $b = ac.$
If $a$ divides $b,$ then we use the notation: \[a \mid b.\]If $a$ does not divide $b,$ then we use the notation: \[a \nmid b.\] When $a$ divides $b,$ we say $a$ is a *divisor* of $b$ and that $b$ is a *multiple* of $a.$


****
.Example {counter:numex}
Does $3$ divide $12$? Does $5$ divide $27$?

.Solution
Since we have \[12 = 3 \cdot 4,\]we see that $3 \mid 12.$ However, there is no integer $c$ such that \[27 = 5c.\]This implies that $5 \nmid 27.$
****

There are several theorems that can be proven just using the definition of divisibility given above. One such theorem is as follows.


.Theorem
****
Let $a$ be a nonzero integer and let $b$ and $c$ be integers such that $a \mid b$ and $a \mid c.$ Then, for any integers $x$ and $y,$ \[a \mid \left(bx + cy\right).\]
****

=== Division Algorithm
.The Division Algorithm
****
Let $a$ be an integer and let $d$ be a positive integer. Then, there are unique integers $q$ and $r,$ with $0 \leq r < d,$ such that \[a = dq + r.\]
****

Let $a$ be an integer and let $d$ be a positive integer. Suppose that $q$ and $r$ are integers given by the division algorithm. We refer to $q$ as the *quotient* and $r$ as the *remainder*. We use the following notation:

[env.equationalign]
--
a \boldsymbol{\operatorname{\,div\,}} d &= q,\\
a \boldsymbol{\bmod} d &= r.\\
--

****
.Example {counter:numex}
Find $129 \boldsymbol{\operatorname{\,div\,}} 7$ and $129 \boldsymbol{\bmod} 7.$

.Solution
We have \[129 = 7 \cdot 18 + 3.\] This implies that \[129 \boldsymbol{\operatorname{\,div\,}} 7 = 18\]
and \[129 \boldsymbol{\bmod} 7 = 3.\]
****

If $b$ is an integer and $a$ is a positive integer, the following theorem shows how we can use the division algorithm to determine whether or not $a$ divides $b.$

.Theorem
****
Let $a$ be a positive integer and let $b$ be an integer. Then $a \mid b$ if and only if $b \boldsymbol{\bmod} a = 0.$
****

For any positive integer $m,$ we define $\mathbb{Z}\_{m}$ to be the set of nonnegative integers less than $m.$
In other words, we have \[\mathbb{Z}_m = \{0,1,\dots,m-1\}.\]
Let $a$ and $b$ be elements of $\mathbb{Z}_m.$ We define addition in $\mathbb{Z}_m,$
denoted $+_m,$ as follows: \[a +_m b = (a + b) \boldsymbol{\bmod} m.\] We define
multiplication in $\mathbb{Z}_m,$ denoted $\cdot_m,$ as
follows: \[a \cdot_m b = (a \cdot b) \boldsymbol{\bmod} m.\]

****
.Example {counter:numex}
Use the definition of addition and multiplication
in $\mathbb{Z}\_{11}$ to find $7 +\_{11} 9$ and
$7 \cdot\_{11} 9= 7 \ \ ×_{\mathbf{11}}\ 9.$

.Solution
We have
[env.equationalign]
--
7 +\_{11} 9 &= (7 + 9)\boldsymbol{\bmod} 11\\
&= 16 \boldsymbol{\bmod} 11\\
&= 5,
--
and
[env.equationalign]
--
7 \ \ ×_{\mathbf{11}}\ 9=7 \cdot\_{11} 9 &= (7 \cdot 9)\boldsymbol{\bmod} 11\\
&= 63 \boldsymbol{\bmod} 11\\
&= 8.
--
****

****
.Example {counter:numex}
Find addition and muliplication tables for $\mathbb{Z}\_6.$
.Solution
We have \[\mathbb{Z}\_6 = \{0,1,2,3,4,5\}.\]We have the following table for addition in $\mathbb{Z}\_6$: \[\begin{array}{c|cccccc}
+\_6 & 0 & 1 & 2 & 3 & 4 & 5\\
\hline
0 & 0 & 1 & 2 & 3 & 4 & 5\\
1 & 1 & 2 & 3 & 4 & 5 & 0\\
2 & 2 & 3 & 4 & 5 & 0 & 1\\
3 & 3 & 4 & 5 & 0 & 1 & 2\\
4 & 4 & 5 & 0 & 1 & 2 & 3\\
5 & 5 & 0 & 1 & 2 & 3 & 4\\
\end{array}\] We have the following table for multiplication in $\mathbb{Z}\_6$: \[\begin{array}{c|cccccc}
\cdot\_6 & 0 & 1 & 2 & 3 & 4 & 5\\
\hline
0 & 0 & 0 & 0 & 0 & 0 & 0\\
1 & 0 & 1 & 2 & 3 & 4 & 5\\
2 & 0 & 2 & 4 & 0 & 2 & 4\\
3 & 0 & 3 & 0 & 3 & 0 & 3\\
4 & 0 & 4 & 2 & 0 & 4 & 2\\
5 & 0 & 5 & 4 & 3 & 2 & 1\\
\end{array}\]
****

=== Greatest Common Divisor and Least Common Multiple

Let $a$ and $b$ be positive integers. The largest positive integer $d$ such that $d$ divides $a$ and $d$ divides $b$ is referred to as the *greatest common divisor* of $a$ and $b.$ The greatest common divisor of $a$ and $b$ is denoted by $\gcd(a,b).$ If $\gcd(a,b) = 1,$ we say that $a$ and $b$ are *relatively prime*.

****
.Example {counter:numex}
Find the greatest common divisor of $35$ and $21.$ Are $35$ and $21$ relatively prime?

.Solution
Since $35 = 7 \cdot 5$ and $21 = 7 \cdot 3,$ we see that $7$ is a common divisor of $35$ and $21.$ It can be checked that no positive integer larger than $7$ that divides both $35$ and $21.$ Thus, we see that \[\gcd(35,21) = 7.\]Since $\gcd(35,21) \neq 1,$ we see that $35$ and $21$ are not relatively prime.
****

Additionally, it is not hard to see that $\gcd(5,3) = 1,$ and thus $\frac{35}{7}$ and $\frac{21}{7}$ are relatively prime. In general, we have the following theorem.

.Theorem
****
Let $a$ and $b$ be positive integers. Suppose that $d$ is a positive integer such that $d \mid a$ and $d \mid b.$ Then, $d = \gcd(a,b)$ if and only if $\frac{a}{d}$ and $\frac{b}{d}$ are relatively prime.
****

Let $a$ and $b$ be positive integers. The smallest positive integer $m$ such that $a$ divides $m$ and $b$ divides $m$ is referred to as the _least common multiple_ of $a$ and $b.$ The least common multiple of $a$ and $b$ is denoted by $\operatorname{lcm}(a,b).$

****
.Example {counter:numex}
Find the least common multiple of $35$ and $21.$

.Solution
Since $105 = 35 \cdot 3$ and $105 = 21 \cdot 5,$ we see that $105$ is a common multiple of $35$ and $21.$ It can be checked that no positive integer smaller than $105$ is a multiple of both $35$ and $21.$ Thus, we see that \[\operatorname{lcm}(35,21) = 105.\]
****

Additionally, we observe that \[\gcd(35,21) \cdot \operatorname{lcm}(35,21) = 7 \cdot 105 = 735 = 35 \cdot 21.\]
In general, we have the following theorem.

.Theorem
****
Let $a$ and $b$ be positive integers. Then, \[\gcd(a,b) \cdot \operatorname{lcm}(a,b) = ab.\]
****

=== The Euclidean Algorithm

A well-known method for computing the greatest common divisor and least common multiple of a pair of positive integers is called the *Euclidean algorithm*. Before describing this algorithm, we state the following theorem.

.Theorem
****
Let $a,b,r,q$ be integers with $a=bq+r$. Then, \[\gcd(a,b) = \gcd(b,r).\]
****

Let $a$ and $b$ be positive integers. We let $r\_0 = a$ and $r\_1 = b.$ Next, we use the division algorithm to find integers $q\_1$ and $r\_2,$ with $0 \leq r\_2 < r\_1,$ such that \[r\_0 = r\_1q\_1 + r\_2.\]Then, if $r\_2 \neq 0,$ we again use the division algorithm to find integers $q\_2$ and $r\_3,$ with $0 \leq r\_3 < r\_2,$ such that \[r\_1 = r\_2q\_2 + r\_3.\] We continue this process until we obtain a remainder of $0$; that is, until, for some positive integer $k,$ we have $r\_{k+1} = 0.$ Then, we have

[env.equationalign]
--
\gcd(a,b) = r\_k,\\
\operatorname{lcm}(a,b) = \frac{ab}{r\_k}.\\
--

****
.Example {counter:numex}
Find the greatest common divisor and least common multiple of $480$ and $174.$

.Solution
We have the following:

[env.equationalign]
--
480 &= 174 \cdot 2+ 132,\\
174 &= 132 \cdot 1 + 42,\\
132 &= 42 \cdot 3 + 6,\\
42 &= 6 \cdot 7 + 0.
--

Since we have reached a remainder of 0, we are finished. The last nonzero remainder we found was $6.$ Thus, we see that \[\gcd(480,174) = 6,\]and that \[\operatorname{lcm}(480,174) = \frac{480\cdot 174}{6} = 13920.\]
****

:pt_code_height: 550
:pt_rawinput: false
:pt_code: a%20%3D%20int%28input%28%22a%20%3D%20%22%29%29%0Ab%20%3D%20int%28input%28%22b%20%3D%20%22%29%29%0Ar%20%3D%20%5Ba,b%5D%0Aq%20%3D%20%5B%5D%0Ak%20%3D%200%0Awhile%20r%5Bk%2B1%5D%20!%3D%200%3A%0A%20%20%20%20k%20%2B%3D%201%0A%20%20%20%20q.append%28r%5Bk-1%5D//r%5Bk%5D%29%0A%20%20%20%20r.append%28r%5Bk-1%5D%25r%5Bk%5D%29%0A%20%20%20%20print%28%22%25d%20%3D%20%25d%20*%20%25d%20%2B%20%25d%22%20%25%20%28r%5Bk-1%5D,r%5Bk%5D,q%5Bk-1%5D,r%5Bk%2B1%5D%29%29%0Aprint%28%22gcd%28%25d,%25d%29%20%3D%20%25d%22%20%25%20%28a,b,r%5Bk%5D%29%29%0Aprint%28%22lcm%28%25d,%25d%29%20%3D%20%25d%22%20%25%20%28a,b,a*b//r%5Bk%5D%29%29

.Euclidean Algorithm
****
--
--
Here is an implementation in Python of the Euclidean algorithm as it computes $\gcd(a,b)$ and $\operatorname{lcm}(a,b).$

include::python_tutor.adoc[]
****
Additionally, we can use the work from the solution to the previous example to obtain the following:

[env.equationalign]
--
6 &= 132 - 42\cdot 3,\\
42 &= 174 - 132\cdot 1,\\
132 &= 480 - 174 \cdot 2.
--

We express $\gcd(480,174)$ as a sum of multiples of $480$ and $174$ as follows:

[env.equationalign]
--
6 &= 132 - 42 \cdot 3\\
&= 132 - (174 - 132\cdot 1)\cdot 3\\
&= 132 - 174 \cdot 3 + 132 \cdot 3\\
&= 132 \cdot 4 - 174 \cdot 3\\
&= (480 - 174\cdot 2)\cdot 4 - 174 \cdot 3\\
&= 480 \cdot 4 - 174 \cdot 8 - 174 \cdot 3\\
&= 480 \cdot 4 -174 \cdot 11\\
&= 480 \cdot 4 + 174 \cdot (-11).
--

In general, we have the following theorem.

.Theorem
****
Let $a$ and $b$ be positive integers. There exist integers $x$ and $y$ such that \[\gcd(a,b) = ax + by.\]
****

Particular values of $x$ and $y$ can be found using the Extended Eulcidean algorithm.

:pt_code_height: 650
:pt_rawinput: false
:pt_code: a%20%3D%20int%28input%28%22a%20%3D%20%22%29%29%0Ab%20%3D%20int%28input%28%22b%20%3D%20%22%29%29%0Ar%20%3D%20%5Ba,b%5D%0Aq%20%3D%20%5B%5D%0Ak%20%3D%200%0Awhile%20r%5Bk%2B1%5D%20!%3D%200%3A%0A%20%20%20%20k%20%2B%3D%201%0A%20%20%20%20q.append%28r%5Bk-1%5D//r%5Bk%5D%29%0A%20%20%20%20r.append%28r%5Bk-1%5D%25r%5Bk%5D%29%0Aprint%28%22gcd%28%25d,%25d%29%20%3D%20%25d%22%20%25%20%28a,b,r%5Bk%5D%29%29%0Ax%20%3D%20%5B1%5D%0Ay%20%3D%20%5B-q%5Bk-2%5D%5D%0Afor%20i%20in%20range%28k-2%29%3A%0A%20%20%20%20print%28%22%25d%20%3D%20%25d%20*%20%25d%20%2B%20%25d%20*%20%25d%22%20%25%20%28r%5Bk%5D,%20r%5Bk-2-i%5D,%20x%5Bi%5D,%20r%5Bk-1-i%5D,%20y%5Bi%5D%29%29%0A%20%20%20%20x.append%28y%5Bi%5D%29%0A%20%20%20%20y.append%28x%5Bi%5D%20-%20q%5Bk-3-i%5D*y%5Bi%5D%29%20%20%20%20%0Aprint%28%22%25d%20%3D%20%25d%20*%20%25d%20%2B%20%25d%20*%20%25d%22%20%25%20%28r%5Bk%5D,%20r%5B0%5D,%20x%5Bk-2%5D,%20r%5B1%5D,%20y%5Bk-2%5D%29%29
****
.Example {counter:numex} - Extended Euclidean Algorithm in Python
--
--
Here is an implementation in Python of the Extended Euclidean algorithm as it finds integers $x$ and $y$ such that $ax + by = \gcd(a,b).$

include::python_tutor.adoc[]
****
// MKD - moved divisibility and gcd content to induction chapter
////





//MKD
//// 
// unreviewed original content 1
Types of statements that can be proven by induction:

* Summation formulas:
Prove that   1(1!) + 2(2!) + · · · + n(n!) = (n + 1)! – 1, for all positive integers.

* Inequalities:
Prove that $2^n < n!$ for every positive integer $n$ with $n ≥ 4$.

* Divisibility:
Prove that $n^3+2n$ is divisible by 3 for every positive integer $n$.

* Sets:
Prove that if $S$ is a set with $n$ elements where $n$ is a nonnegative integer, then $S$ has $2^n$ subsets.

* Algorithms: Prove that the recursively defined algorithm fac(n) returns $n!$ for all nonnegative integers.

****
def fac(n)

 begin

 if n = 0 then

 return 1

 else

 return n · fac(n − 1)

end
****


****
.Example {counter:MKDinductionexample} - A Summation Formula
Prove by mathematical induction $1·1!+2·2!+3·3!+···+n· n!=\underset{k=1}{\overset{n}{\sum }}k\left( k!\right) =\left(n+1\right)!-1$

.Solution:
For each integer $n$, let $P(n)$ be the statement $P(n):\sum\limits_{k=1}^{n} k\left( k!\right) =\left(n+1\right)!-1$

To prove using induction we need

* Base case: $P(1)$ is true

* Inductive step: For all integers $m>0$, if $P(m)$ is true, then $P(m+1)$ is true.


Base Case: Substitute $n=1$ into $ \sum\limits_{k=1}^{n}k(k!)=\left(n+1\right)!-1$

$ \sum\limits_{k=1}^{1} (k)k!\overset{?}{=}\left(1+1\right)!-1$

Simplify both sides to check for validity: 1==1, therefore the base case is true.

Begin the inductive step by assuming P(m) for some integer m>0.

Assume $P(m):\sum\limits_{k=1}^{m}k(k!)=\left(m+1\right)!-1$ for some integer m>0.

Write down the left hand side of P(m+1):

$P(m+1):\sum\limits_{k=1}^{m+1}k(k!)$

Extract (m+1) (m+1)! from the summation,

$\sum\limits_{k=1}^{m+1} k(k!)=\sum\limits_{k=1}^{m}kk!+(m+1)!(m+1)$

Apply the induction hypothesis by replacing $\sum\limits_{k=1}^{m}k(k!)$ with (m+1)!-1,

$\sum\limits_{k=1}^{m+1}k(k!)=((m+1)!-1)+(m+1)!(m+1)$

Simplify the result:

$\sum\limits_{k=1}^{m+1}k(k!)=-1+2\left(m+1\right)!+\left(m+1\right)!m$

$=-1\ +(m+1)(2+m)=(m+2)!\ -1\ =((m+1)+1)!-1$

Express the result in terms of m+1,

$\sum\limits_{k=1}^{m+1}k(k!)=((m+1)+1)!-1$

Therefore, the inductive step has been verified $\sum\limits_{k=1}^{m+1}k(k!)=((m+1)+1)!-1$
****
//MKD
//// 
// unreviewed original content 1


// MKD Delete this example since it duplicates the motivating example at the beginning of the chapter.
////
// MKD end of sum of odds example
//
****
.Example {counter:MKDinductionexample} -  Another Summation Formula
Prove  the proposition that the sum of the ﬁrst n odd numbers is $n^2$; that is,

$1+3+5+···+2n-1=\sum_{k=1}^{n} (2k-1) =n^2$ for n a positive integer $n\in\mathbb{Z}$

.Solution:
For each integer n, let P(n) be the statement $\sum_{k=1}^{n} \left(2k-1 \right)=n^2$
$P\left(n\right):\sum_{k=1}^{n} \left(2k-1 \right)=n^2$

Base case: P(1) is true.

Inductive step: For all integers m>0, if P(m) is true, then P(m+1) is true.
If the above properties hold, then for each n$\in\mathbb{Z}$ where n>0, the statement P(n) is true.

Substitute n=1 into
$\sum_{k=1}^{n} (2k-1)=n^2$

$\ \sum_{k=1}^{1} (2k-1)\overset{?}{=}1^2 $

Simplify both sides to check for validity:

1=1, therefore the base case is true and the inductive step can be taken.

Begin the inductive step by assuming $P(m)$ for some integer $m>0$.
Assume for some integer m>0

$P(m):\ \sum_{k=1}^{m} (2k-1)=m^2$

Write down the left-hand side of $P(m+1)$:

$\text{LHS }  P(m+1):\ \sum_{k=1}^{m+1}{(2k-1)}$

Extract $ (m+1)-1$ from the summation,

$\sum_{k=1}^{m+1} (2k-1)=\sum_{k=1}^{m}{(2k-1)}+(2(m+1)-1)$

Apply the induction hypothesis by replacing $\sum_{k=1}^{m}{(2k-1)}$, with $m^2$.

$\sum_{k=1}^{m+1} \left(2k-1\right)=m^2 +(2(m+1)-1)=m^2+2m+2-1$

$=m^2+2m+2\ =m^2 +2m+2(m+1)^2$

Simplify the result expressing in terms of $m+1$:

$\sum_{k=1}^{m+1} {(2k-1)}={(m+1)}^2$.

In other words, $\sum_{k=1}^{m} {(2k-1)}=m^2$, implies $\sum_{k=1}^{m+1} {(2k-1)}=(m+1)^2$.

Therefore, the inductive step has been verified.
****
////
// MKD end of sum of odds example
//


//MKD
//// 
// unreviewed original content 2

****
.Example {counter:MKDinductionexample} - Inequality
Prove that $n! > 3^n$ for every positive integer $n$ with $n > 6$.

.Solution:
Since the base case value must be greater than 6, the base case value will be set to the next integer after 6, $n=7$.

Does $7!\overset{?}{=}3^7$?

Simplify both sides to check for validity:
$5040>2187$, therefore the base case is true and the inductive step can be taken.

Begin the inductive step by assuming P(m) for some integer m>6.
Assume,

$P(m):\ m!>3^m,$ for some integer m>6.

We want to show this implies P(m+1) or,

$P(m+1):\ (m+1)!>3^{m+1}$.

Write down the left hand side of

$\text{LHS } \ P(m+1) : (m+1)!$

Factor out $m+1$ from $(m+1)!$:

$(m+1)!=m! (m+1)$

Using the induction hypothesis $ m!>3^m$, then

$ m!(m+1)>3^m(m+1)$,

$\left(m+1\right)!>3^m\left(m+1\right)$,

Using $m+1>3$, then

$3^m (m+1)>3^m3$

Combining exponents, $3^m 3=3^{m+1}$

$(m+1)!>3^{m+1}$

$m!>3^m$ implies  $(m+1 )!>3^{m+1}$.

.Graphs of $n!$, and $3^n$, showing $n! > 3^n$, for $n>6$.

image::images/induction3.png[]
****

****
.Example {counter:MKDinductionexample} - Divisibility

Prove the following using the principle of mathematical induction:

$n^2 + n$ is even (or divisible by 2), for $n > 0$.

.Solution:
Since the base case value must be greater than 0, the base case value will be set to the next integer after 0: $n=1$.
For each integer $n$, let $P(n)$ be the statement $n^2 + n$ is divisible by 2.

[NOTE]
====
$n^2+n$ is divisible by 2 if and only if $\left(n^2+n\right)\mod 2=0$.
====

Prove $\left(n^2+n\right)\mod 2=0$, for $n>0$.

Substitute $n = 1$ into $\left(n^2+n\right)\mod 2=0$:

$(1^2 + 1) \mod 2 \overset{?}{=}0$

Simplify both sides to check for validity:

$2  \mod 2 = 0$, therefore the base case is true and the inductive step can be taken.

Begin the inductive step by assuming $P(m)$ for some integer $m > 0$:

Assume $P(m):\ \left(m^2+km\right)\mod 2=0$ for some integer $m>0$.
Write down the left hand side of P(m+1):

$\text{LHS }\ P(m+1):\ \left(m+1\right)^2+\left(m+1\right)$


Expand $\left(m+1\right)^2+\left(m+1\right)=m^2+2m+m+2$ and isolate $m^2+m$ as its own term:

$(m+1)^2+(m+1)=\left(m^2+m\right)+\left(2m+2\right)$


Factor 2 from $2m+2$:  $ \left(m^2+m\right)+2\ \left(m+1\right)$.

The induction hypothesis states that $m^2+m$ is divisible by 2: $\left(m^2+m\right)\mod 2=0$, and $2 (m+1)$ has 2 as a factor explicitly, so

$\left(2\left(m+1\right)\right)\mod 2=0$ and
$\left(m^2+m\right)\mod 2=0$ implies

$\left((m+1)^2+(m+1)\right)\mod 2=0$

Therefore, the inductive step has been verified.
****
//MKD
//// 
// unreviewed original content 2


// MKD - strong induction section needs cleanup/rewrite
== Strong Induction
Recall the idea behind mathematical induction, prove that a proposition //$P\left(m\right)$  
$P_n$ is true for a base step, say $P_1$. Then prove the inductive step. This involves proving that $P_k$ implies $P_{k+1}$.
*Strong induction* is a generalized version of induction where in the inductive step we assume $P_1, P_2,\ldots, P_m$ is true and show all these together imply $P_{m+1}$ is true.


Strong version of Mathematical Induction:

* Base Case: Prove the first statement $P_1$. (Or the first several $P_r$, if needed.)

* Inductive Step: Given any integer $m \geq 1$, prove  $P_1\land {P_2\land {\ P_3\land {\ldots\land {P_m,\ }}}}$ implies  $P_{m+1}$

Algorithmically:

* Base Case: Prove that $P_{1,\ }P_2\ ,\ldots,\ P_r$, are all true.

* Inductive Hypotheses: Assume, $P_{1,\ }P_2\ ,\ldots,\ P_m$are all true for some $m  ≥ 1$,

* Inductive step: Assuming, $P_{1,\ }P_2\ ,\ldots,\ P_m$ are all true for some  $ m  ≥ 1$,  prove that $P_{m+1}$ is true.

****
.Example {counter:MKDinductionexample} - Recurrence Relations
Consider the sequence $\left\{a_n\right\}$ defined as a a recurrence relation,

$a_1=5$, $a_2=13$, and $a_{n+2}=5a_{n+1}-6a_n$, for all $n \geq 1$.

Prove that $a_n=2^{n} +3^{n}$.

.Solution
Base case: Consider the case $n=1$, $a_1=5=2^{1} +3^{1}$, and $a_2=13=2^2 +3^2=4+9$.

Induction hypothesis: Assume $a_1,\ a_2,..a_m$ are all given by $a_m=2^m + 3^m$.

We want to show that $a_{m+1}=2^{m+1} +3^{m+1}$.

Well, $ a_{m+1}=5a_m-6a_{m-1}$, using the definition of the recurrence relation.

By the inductive hypothesis, $a_m=2^m+3^m$ and $a_{m-1}=2^{m-1} +3^{m-1}$.

$ a_{m+1}=5\left(2^m +3^m \right)-6\left(2^{m-1} +3^{m-1}\right)$.

Consider then,

[env.equationalign]
--
5\left(2^m+ 3^m \right)-6\left(2^{m-1} +3^{m-1}\right) &=5\times 2^m +5\times 3^m -6\times 2^{m-1} -6\times 3^{m-1}\\
&=5\times 2^m+5\times 3^m-3\times 2\times 2^{m-1}-2\times 3\times 3^{m-1}\\
&=5\times\ 2^m+5\times 3^m-3{\times 2}^m-2\times 3^m\\
&=\left( 5\times 2^m-3\times 2^m \right) + \left( 5 \times 3^m -2\times 3^m \right)\\
&=\left(5-3\right) \times 2^m + \left(5-2\right) \times 3^m\\
&=2\times\ 2^m+3\times 3^m\\
&=2^{m+1} + 3^{m+1}
--

So $a_{m+1}=2^{m+1} + 3^{m+1}$ and therefore, $a_n=2^n +3^n$ for all $n \geq 1$.
****


MORE TO COME!


//MKD
//// 
// unreviewed original content 3

== Exercises
Prove using induction.

. For  all $n ≥ 1$ prove that $1+2+3+\ldots+n=\displaystyle\sum_{i=1}^{n}i=\displaystyle \frac{n\left(n+1\right)}{2}$

. For  all $n ≥ 1$ prove that $1^2+2^2+3^2+\ldots+n^2=\displaystyle\sum_{i=1}^{n}i^2=\frac{1}{6} n (n+1) (2 n+1)$

. For  all $n ≥ 1$ prove that $1^3+2^3+3^3+\ldots+n^3=\displaystyle\sum_{k=1}^{n}k^3=\frac{1}{4} n^2 (n+1)^2$

. For all $n ≥ 1$, prove that ${23}^n-1$  is  divisible  by 11.

. Prove by induction that $n^2+n = n(n+1)$ is even for all integers $n  ≥ 1$.

. Find an appropriate $N \in \mathbb{Z}$, and prove by induction that $n^3 +3n^2$ is even for all $n  ≥ N$.

. Find an appropriate $N \in \mathbb{Z}$, and prove by induction that $n^3 +2n$ is divisible by 3 for all $n  ≥ N$.
*(Hint: You may use the result $n(n+1)$, is even for $n$, an integer.)*

. Prove by induction that $7$ divides $2^{4n+2} + 3^{2n+1}$ for all nonnegative integers $n$.

. Prove that for any $n  ≥ 1$ and $x  ≥ 0$ that $\left(1+x\right)^n\geq1+nx$.

. For all $n  ≥ 5$, prove that $ 2^n>n^2$.

. For all $n  ≥ 5$, prove that $ 2^n>n^2$.

. Graph $n!$ and $2^n$, and then prove by induction that $ n! > 2^n$, for $n>3$.

. Graph $n^3$ and $5n+12$, and then use your graph to find an appropriate $N \in \mathbb{Z}$ to prove by induction that
$ n^3 > 5n+12$ whenever $n>N$.



. Prove by induction that a set  $A$ with cardinality $|A|=n$ has $2^n$ subsets.
. Prove by induction that there are $3^n$ numbers in base 3 (using the digits 0 ,1, 2) made up of $n$ digits.
. Prove by induction that there are $4^n$ numbers in base 4 (using the digits 0 ,1, 2, 3,) made up of $n$ digits.

. State the principle of mathematical induction using a conditional logical statement.

. Consider the sequence defined recursively as $a_1=1,a_2=5,$ and $a_n=5a_{n-1}-6a_{n-2}.$
.. Calculate the first eight terms of the recursive sequence.
.. Prove by induction that the recursive sequence is given by the formula $a_n=3^n-2^n.$

. Consider the sequence defined recursively as $a_1=1$ and $a_n=2a_{n-1}+n$.
.. Calculate the first eight terms of the recursive sequence
.. Prove by induction that the recursive sequence is given by the formula $a_n={4\cdot2}^{n-1}-n-1$.

. Prove by induction that the sum of the first $n$ Fibonacci numbers is
\[
f_1+f_2+\ldots+f_n=\sum_{i=1}^{n}{f_i=f_{n+2}-1}.
\]

.	Prove by induction that the sum of the squares of the first $n$, Fibonacci numbers is
\[
f_1^2+f_2^2+ \cdots + f_n^2 = \sum_{i=1}^{n} f_i^2=f_n \cdot\ f_{n+1}.
\]

//MKD
//// 
// unreviewed original content 3
